# 더티 플래그

> 불필요한 작업을 피하기 위해 실제로 필요할 때까지 그 일을 미룬다.
> 

⇒ 특정 객체가 변경되었을 때만 추가 작업을 수행하도록 함으로써 불필요한 계산이나 처리 비용을 줄이는 데 유용

---

### 들어가기 앞서…

이 장에서는 절대 좌표, 상대 좌표 갱신을 예제로 들었다.

먼저 절대 좌표, 상대 좌표가 뭔지 알고 가자.

- 절대 좌표 : 월드 좌표계를 기준으로 현재 위치 나타내는 것
- 상대 좌표 : 오브젝트를 기점으로 현재 위치를 나타내는 것

---

# 동기

다음과 같은 상황이 있다고 해보자. 

바다 위에 있는 해적선의 망루 위에 해적이 타고 있고 해적 어깨 위에 앵무새가 있다. 해적선이 움직이면 해적, 앵무새의 위치도 같이 움직인다. 

![image](https://github.com/user-attachments/assets/c282c40b-d217-4f8a-b3f9-1161e22aef0b)


여기서 화면에 앵무새를 그리기 위해서는 앵무새의 절대 위치를 알아야 한다. 객체를 그리기 위해서는 객체의 상대 좌표(Local Transform)가 아닌 절대 좌표(World Transform)를 알아야 한다. 

```cpp
객체를 그리기 위해서는 절대 좌표(World Transform)를 알아야 한다. 
```

객체의 절대 좌표 계산은 쉽다. 그저 변환 행렬의 곱이다. 

```cpp
앵무새의 절대 좌표 = 배의 상대 좌표 * 해적 상대 좌표 변환 * 앵무새 상대 좌표
```

하지만 이 연산을 모든 물체에서 매 프레임마다 수행하는 것은 귀중한 CPU자원을 낭비하는 것이다. 

### 월드 변환 값 캐싱

전혀 움직이지 않는 물체(지형지물)는 절대 좌표 변환 값을 캐싱하여 최적화할 수 있다. 하지만 움직이는 물체는 어쩔 수 없이 매 프레임마다 연산을 해야 할 것이다. 

만약 움직일 때마다 재계산이 이루어지면 다음과 같이 될 것이다. 특히, 최상위 부모의 트랜스폼이 변화하면 계층을 따라 내려오면서 하위 객체에서도 재귀적으로 연산이 이루어지는데 아래 상황에서는 10번의 연산이 이루어진다. 

<aside>
💡 한 프레임에 배가 바다위에서 출렁

망대는 바람에 흔들

해적은 망대 위에 있고 

앵무새는 해적의 머리 위를 왔다 갔다 한다. 

</aside>

<aside>
💡 계산 과정

→ 배 이동

- 배 절대 좌표 재계산
- 망대 절대 좌표 재계산
- 해적 절대 좌표 재계산
- 앵무새 절대 좌표 재계산

→ 망대 이동

- 망대 절대 좌표 재계산
- 해적 절대 좌표 재계산
- 앵무새 절대 좌표 재계산

→ 해적 이동

- 해적 절대 좌표 재계산
- 앵무새 절대 좌표 재계산

→ 앵무새 이동

- 앵무새 절대 좌표 재계산
</aside>

### 재계산 미루기

이 문제를 해결하기 위해 먼저 상대 좌표 변환, 절대 좌표 변환 업데이트를 분리한다. 
그리고 각자 이동한 좌표를 갖고 있다가 랜더링하기 직전에 한꺼번에 절대 좌표를 계산하면 편할 것이다. 이를 위해 객체에 “플래그”를 추가한다. 

<aside>
💡 계산 과정

→ 배 이동                                  ok, keep

→ 망대 이동                              ok, keep

→ 해적 이동                              ok, keep

→ 앵무새 이동                           ok, keep

---

랜더링

- 배 절대 좌표 계산
- 망대 절대 좌표 계산
- 해적 절대 좌표 계산
- 앵무새 절대 좌표 계산
</aside>

책에서 플래그를 다음과 같이 설명한다.

> 플래그 : 둘 중 하나의 상태만 될 수 있는 작은 데이터. 비트와 같은 말로 표식용 변수 1bit이다.
> 

패턴 이름인 “더티 플래그”에서 “더티”는 “flag가 false인 경우”, "더 이상 맞지 않음"를 의미하여 더티 플래그라고 한다. 

```cpp
bool flag = false;
```

- 로직
1. LocalTransform의 값이 바뀌면 플래그를 true로 한다.
2. 객체의 WorldTransform값이 필요할 때에는 플래그를 검사한다. 
3. 플래그가 켜져있으면 WorldTransform을 계산한 뒤에 플래그를 false로 바꾼다. 
4. 꺼져있다면 움직이지 않았으므로 기존 WorldTransform으로 랜더링한다. 

이걸로 움직이는 객체만 절대 좌표 변환을 해서 최적화를 할 수 있다. 

```cpp
void GraphNode::setTransform(Transform local) 
{
    local_ = local;
    dirty_ = true;
}

void render(const Transform& parentWorld, bool dirty = false)
{
    // 상위 노드의 플래그 중 하나라도 켜져있으면 켜진다
    dirty |= dirty_;

    if (dirty) {
        world_ = local_.combine(parentWorld);
        dirty_ = false;
        // Combine 호출 횟수를 기록
        combineCallCount++;
    }


    if (mesh_) renderMesh(mesh_, world_);

    for (int i = 0; i < numChildren_; i++)
        children_[i]->render(world_, dirty);
}
```
# 내가 이해한 예시
위 예시가 너무 어려워서 쉽게 생각해봤다.
어떤 게임에서 플레이어가 데미지를 1번 입었을 때, 기획 상 캐릭터는 무적상태가 된다고 해보자.
이때, 데미지가 한프레임에 동시에 2개가 들어왔다고 했을 때, 하나는 무시해야 한다. 
- 잘못된 예시
```cpp
TakeDamage(int damage)
{
    bDamaged = true;
	Invincible();	
}

Invincible()
{
    Timer(3)[bDamaged]{bDamaged = false;};
}
```
이러한데 여기에 더티를 넣으면 다음과 같다. 
```cpp
TakeDamage(int damage)
{
	if(bDamaged == false)
	{
		bDamaged = true;
		Invincible();
	}
}

Invincible()
{
    Timer(3)[bDamaged]{bDamaged = false;};
}
```

# 패턴

- 기본값(Primary Data) : 최종 값(위 예시는 상대 좌표)
- 파생값(Derived Data) : 기본값에 비싼 작업을 거쳐야 얻을 수 있는 값

⇒ 더티 플래그는 파생값이 참조하는 기본값의 변경 여부를 추적한다.

<aside>
💡 <과정>

1. 기본값이 변경되면 더티 플래그가 켜진다. 
2. 파생값을 써야 할 때, 더티 플래그가 켜져 있다면 다시 연산을 한 뒤에 플래그를 끈다. 
3. 플래그가 꺼져있다면 이전에 캐시해놓은 파생값을 그대로 사용한다. 
</aside>

# 언제 쓰나??

주로 성능 최적화나 리소스 관리에 쓴다. 코드가 복잡해지는 걸 감수할 정도로 성능 문제가 심할 때만 사용해야 한다. 

- 파생값을 얻는데 비용이 클 경우(비용이 크지 않으면 굳이 넣을 필요 없다.)


# 주의 사항

### 너무 오래 지연하려면 비용이 든다.

엄밀히 말하자면 GC는 더티 플래그는 아니지만 GC를 정리하는 것도 일종의 지연인데 GC 정리를 너무 빨리하는 것도 성능의 하락이 생기지만 너무 늦게 정리하는 것도 비용이 크게 발생된다. 

### 상태가 변할 때마다 플래그를 일일이 켜줘야 한다.

한 군데라도 놓치면 무효화된 파생 값을 사용해서 잡기 어려운 버그가 발생할 수도 있다. 그리고 지연 도중에 뭔가 잘못되었을 경우 작업이 전부 날아갈 수도 있다는 문제도 있다.

### 이전 파생값을 캐싱해둬야 한다.

더티 플래그가 **꺼져** 있으면 캐싱된 값을 그대로 사용해야 하기 때문에 이전 파생값을 계속 갖고 있어야 한다. 다른 최적화 방법들과 마찬가지로 더티 플래그 패턴 역시 속도를 위해 메모리를 희생한다.

# 게임 속 패턴

언리얼 엔진 소스 코드에 dirty라고 검색하면 상당히 많은 곳에서 쓰이고 있는 것을 볼 수 있다. 

![image](https://github.com/user-attachments/assets/7f28195e-1e2e-4181-8b11-08605a85d040)


- Fixed up Redirector

파일 참조 경로 재설정해주는 곳에도 이 dirty가 쓰인다. 

- 패키지 및 객체의 변경 여부(생성, 삭제)를 추적
- 에셋이 변경되었거나 경로가 변경되었을 때 dirty On
- “Fixed up Redirector”을 클릭하면 dirty켜진 것들만 리디렉터 작업 수행.

이 말은 언리얼 콘텐츠 브라우저는 항상 에셋들을 참조 업데이트를 하고 있지 않다는 것이라 추측할 수 있다.

![image](https://github.com/user-attachments/assets/e0d9dd14-a7f4-4dc2-bf78-07a0f2954b0b)


- Collection.h

에셋 모음집을 나타내는 Collection에도 이게 있다. 

![image](https://github.com/user-attachments/assets/d652c387-3381-466f-a742-f50bf130709c)




